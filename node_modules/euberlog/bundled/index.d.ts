// Generated by dts-bundle v0.7.3

declare module 'euberlog' {
    export * from "euberlog/types/index";
    export * from "euberlog/utils/logger";
}

declare module 'euberlog/types/index' {
    export * from "euberlog/types/palette/index";
    export * from "euberlog/types/options/index";
}

declare module 'euberlog/utils/logger' {
    import { Options } from "euberlog/types/options/index";
    /**
        * The logger class, its instances will be the euber loggers.
        */
    export class Logger {
            /**
                * The constructor of the Logger class.
                * @param options The options of the logger. If you want to change only the scope you can pass it as a string.
                */
            constructor(options?: Options | string);
            /**
                * Sets the options of the logger.
                * @param options The options for the logger.
                */
            setOptions(options?: Options | string): void;
            /**
                * Logs an info message. The format is "[INFO] |{SCOPE}| message |object|", where |word| is optional.
                * @param message The message to be logged.
                * @param object An optional object to log.
                */
            info(message: string, object?: any): void;
            /**
                * Logs a success message. The format is "[SUCCESS] |{SCOPE}| message |object|", where |word| is optional.
                * @param message The message to be logged.
                * @param object An optional object to log.
                */
            success(message: string, object?: any): void;
            /**
                * Logs a debug message. The format is "[DEBUG] |{SCOPE}| message |object|", where |word| is optional. If specified in the options, nothing will be logged.
                * @param message The message to be logged.
                * @param object An optional object to log.
                */
            debug(message: string, object?: any): void;
            /**
                * Logs a warning message. The format is "[WARNING] |{SCOPE}| message |object|", where |word| is optional.
                * @param message The message to be logged.
                * @param object An optional object to log.
                */
            warning(message: string, object?: any): void;
            /**
                * Logs an error message. The format is "[ERROR] |{SCOPE}| message |object|", where |word| is optional.
                * @param message The message to be logged.
                * @param object An optional object to log.
                */
            error(message: string, error?: any): void;
            /**
                * Logs one or more empty lines.
                * @param n The number of empty lines. Default is 1.
                */
            br(n?: number): void;
            /**
                * Logs one or more hr lines.
                * @param n The number of hr lines to print. Default is 1.
                * @param color The colour of the font. Default is 'white'.
                * @param symbol The symbol that constitutes the hr. Default is '-'.
                */
            hr(n?: number, color?: string, symbol?: string): void;
    }
}

declare module 'euberlog/types/palette/index' {
    /**
        * A palette definition interface.
        */
    export interface PaletteDefinitions {
            /**
                * The colour for the info logs. Note: the colour can be a valid chalk colour (such as 'white'), an hex colour (such as '#FFFFFF'), an RGB colour (such as '(255, 255, 255)') or a css keyword (such as 'orange')
                */
            info: string;
            /**
                * The colour for the success logs. Note: the colour can be a valid chalk colour (such as 'white'), an hex colour (such as '#FFFFFF'), an RGB colour (such as '(255, 255, 255)') or a css keyword (such as 'orange')
                */
            success: string;
            /**
                * The colour for the debug logs. Note: the colour can be a valid chalk colour (such as 'white'), an hex colour (such as '#FFFFFF'), an RGB colour (such as '(255, 255, 255)') or a css keyword (such as 'orange')
                */
            debug: string;
            /**
                * The colour for the warning logs. Note: the colour can be a valid chalk colour (such as 'white'), an hex colour (such as '#FFFFFF'), an RGB colour (such as '(255, 255, 255)') or a css keyword (such as 'orange')
                */
            warning: string;
            /**
                * The colour for the error logs. Note: the colour can be a valid chalk colour (such as 'white'), an hex colour (such as '#FFFFFF'), an RGB colour (such as '(255, 255, 255)') or a css keyword (such as 'orange')
                */
            error: string;
    }
    /**
        * The colour palette that specifies a colour.
        */
    export interface Palette {
            /**
                * The primary colours, used for the tag and the scope.
                */
            primary: PaletteDefinitions;
            /**
                * The secondary colours, used for the texts.
                */
            secondary: PaletteDefinitions;
    }
}

declare module 'euberlog/types/options/index' {
    import { DeepPartial } from "euberlog/types/deep-partial/index";
    import { Palette } from "euberlog/types/palette/index";
    /**
        * The internal options of the logger.
        */
    export interface InternalOptions {
            /**
                * The color palette that specifies which colour to use for the various log types.
                */
            palette: Palette;
            /**
                * If the debug messages will be printed.
                */
            debug: boolean;
            /**
                * The scope of the logger, printed as {SCOPE} before the [TYPE] tag.
                */
            scope: string | null;
    }
    /**
        * The options of the logger.
        */
    export type Options = DeepPartial<InternalOptions>;
}

declare module 'euberlog/types/deep-partial/index' {
    type Primitive = string | number | boolean | bigint | symbol | undefined | null;
    type Builtin = Primitive | Function | Date | Error | RegExp;
    type IsTuple<T> = T extends [infer A] ? T : T extends [infer A, infer B] ? T : T extends [infer A, infer B, infer C] ? T : T extends [infer A, infer B, infer C, infer D] ? T : T extends [infer A, infer B, infer C, infer D, infer E] ? T : never;
    export type DeepPartial<T> = T extends Builtin ? T : T extends Map<infer K, infer V> ? Map<DeepPartial<K>, DeepPartial<V>> : T extends ReadonlyMap<infer K, infer V> ? ReadonlyMap<DeepPartial<K>, DeepPartial<V>> : T extends WeakMap<infer K, infer V> ? WeakMap<DeepPartial<K>, DeepPartial<V>> : T extends Set<infer U> ? Set<DeepPartial<U>> : T extends ReadonlySet<infer U> ? ReadonlySet<DeepPartial<U>> : T extends WeakSet<infer U> ? WeakSet<DeepPartial<U>> : T extends (infer U)[] ? T extends IsTuple<T> ? {
        [K in keyof T]?: DeepPartial<T[K]>;
    } : DeepPartial<U>[] : T extends Promise<infer U> ? Promise<DeepPartial<U>> : T extends {} ? {
        [K in keyof T]?: DeepPartial<T[K]>;
    } : Partial<T>;
    export {};
}

